package v1

import (
	"context"
	"encoding/json"
	"github.com/buger/jsonparser"
	"github.com/gin-gonic/gin"
	"github.com/sirupsen/logrus"
	"go_server/models"
	"go_server/pkg/app"
	"go_server/pkg/e"
	"go_server/pkg/format"
	"go_server/pkg/util"
	"go_server/service/robot_service"
	"math/rand"
	"net/http"
	"regexp"
	"strconv"
	"time"
)

// @Summary  下发订单
// @Tags   科技化云平台
// @Accept json
// @Produce  json
// @Param body body models.OrderInfo true "body"
// @Success 200 {object} app.Response
// @Failure 400 {object} app.Response
// @Router /createOrder  [POST]
// @Security ApiKeyAuth
func CreateOrder(c *gin.Context) {
	appG := app.Gin{C: c}
	var reqInfo models.OrderInfo
	err := c.ShouldBindJSON(&reqInfo)
	if err != nil {
		logrus.Error("err = ", err, )
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
		return
	}
	rand.Seed(time.Now().UnixNano())
	taskId := rand.Intn(1000000)

	//TODO 通过正则提取楼栋和楼层信息
	re := regexp.MustCompile(`([0-9]+)B-([0-9]+)F`)
	match := re.FindAllStringSubmatch(reqInfo.DestinationCodes[0], -1)
	logrus.Info("match = ", match[0][1], match[0][2], " ", reqInfo.DestinationCodes[0])
	roomInfo, _ := models.GetRobotPoint(match[0][1], match[0][2])

	//创建现有地图探索任务
	type AutoGenerated struct {
		Distance int `json:"distance"`
		Fov      int `json:"fov"`
		Area     int `json:"area"`
		Mode     int `json:"mode"`
		GridSize int `json:"grid_size"`
	}

	req := format.MqttTaskAddRequest{
		Title: format.TaskStartRequestTitle,
		Content: struct {
			SessionID         string `json:"sessionid"`
			Timestamp         int64  `json:"timestamp"`
			Name              string `json:"name"`
			NickName          string `json:"nickname"`
			UvType            string `json:"type"`
			Cycle             string `json:"cycle"`
			Flags             int    `json:"flags"`
			KillDuration      int64  `json:"duration"`
			CountDown         int    `json:"countdown"`
			PointList         []int  `json:"pointlist"`
			Mode              int    `json:"mode"`
			Date              string `json:"date"`
			Time              string `json:"time"`
			Days              []int  `json:"days"`
			RoomID            int    `json:"room_id"`             //房间ID
			AreaID            int    `json:"area_id"`             //区域ID
			RoomName          string `json:"room_name"`           //房间名
			MapName           string `json:"map_name"`            //地图名
			AutoFinishTimeout int64  `json:"auto_finish_timeout"` //自动恢复时间
			Config            struct {
				Distance int `json:"distance"`
				Fov      int `json:"fov"`
				Area     int `json:"area"`
				Mode     int `json:"mode"`
				GridSize int `json:"grid_size"`
			}
		}{
			SessionID:         util.UUIDShort(),
			Timestamp:         time.Now().Unix(),
			Name:              strconv.Itoa(taskId),
			NickName:          strconv.Itoa(taskId),
			UvType:            "deploy_disinfect", //现有地图
			Cycle:             "immediately",
			Flags:             0,
			KillDuration:      60,
			CountDown:         5,
			PointList:         util.String2ints(",", "1"),
			Mode:              1,
			Date:              "",
			Time:              "",
			Days:              util.String2ints(",", ""),
			RoomID:            roomInfo.AreaID,
			AreaID:            roomInfo.RoomID,
			RoomName:          "",
			MapName:           roomInfo.MapName, //"b749df68-58ec-4013-b95b-3ca7291df227",//
			AutoFinishTimeout: 300,
			Config: struct {
				Distance int `json:"distance"`
				Fov      int `json:"fov"`
				Area     int `json:"area"`
				Mode     int `json:"mode"`
				GridSize int `json:"grid_size"`
			}{
				Distance: 25,
				Fov:      150,
				Area:     600,
				Mode:     1,
				GridSize: 2,
			},
		},
	}

	msgStr, err := json.Marshal(req)
	logrus.Debugln("startTask req", req.Content.Mode, string(msgStr))
	if err != nil {
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
		return
	}

	result, err := robot_service.S.SendMqttMsg(context.Background(), 12, roomInfo.SN, req.Content.SessionID, msgStr)

	if err != nil {
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
		return
	} else if result == "" {
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
		return
	}
	code, _ := jsonparser.GetInt([]byte(result), "content", "code")
	if code != 0 {
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
		return
	}

	logrus.Info("result = ", result)
	data := make(map[string]interface{})
	data["taskId"] = taskId
	if err := models.CreateTask(roomInfo.SN, strconv.Itoa(taskId), reqInfo.DestinationCodes[0]); err != nil {
		logrus.Error("err = ", err, )
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
		return
	}

	appG.Response(http.StatusOK, e.SUCCESS, data)
}

// @Summary  查询订单
// @Tags   科技化云平台
// @Accept json
// @Produce  json
// @Param body body models.OrderIdListInfo true "body"
// @Success 200 {object} app.Response
// @Failure 400 {object} app.Response
// @Router /retrieveOrder  [POST]
// @Security ApiKeyAuth
func RetrieveOrder(c *gin.Context) {
	appG := app.Gin{C: c}
	var reqInfo models.OrderIdListInfo
	err := c.ShouldBindJSON(&reqInfo)
	if err != nil {
		logrus.Error("err = ", err, )
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
		return
	}

	data := make([]struct {
		OrderId int    `json:"orderId"`
		State   string `json:"state"`
	}, 0)

	for _, v := range reqInfo.OrderIdList {
		tasks, err := models.GetTaskByTaskId(v)
		if err != nil {
			logrus.Error("GetTaskByTaskId err = ", err, )
			appG.Response(http.StatusInternalServerError, e.ERROR, nil)
			return
		}
		taskId, _ := strconv.Atoi(tasks.TaskID)
		data = append(data, struct {
			OrderId int    `json:"orderId"`
			State   string `json:"state"`
		}{
			OrderId: taskId,
			State:   tasks.TaskStatus,
		})
	}

	appG.Response(http.StatusOK, e.SUCCESS, data)
}

// @Summary  取消订单
// @Tags   科技化云平台
// @Accept json
// @Produce  json
// @Param body body models.TaskIDInfo true "body"
// @Success 200 {object} app.Response
// @Failure 400 {object} app.Response
// @Router /stop  [POST]
// @Security ApiKeyAuth
func OrderStop(c *gin.Context) {
	appG := app.Gin{C: c}
	var reqInfo models.TaskIDInfo
	err := c.ShouldBindJSON(&reqInfo)
	if err != nil {
		return
	}

	tasks, err := models.GetTaskByTaskId(reqInfo.TaskId)
	if err != nil {
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
		return
	}
	//发送请求，结束任务
	req := format.MqttTaskFinishRequest{
		Title: format.TaskTerminateRequestTitle, //中断任务
		Content: struct {
			SessionID string `json:"sessionid"`
			Timestamp int64  `json:"timestamp"`
			Name      string `json:"name"`
		}{
			SessionID: util.UUIDShort(),
			Timestamp: time.Now().Unix(),
			Name:      reqInfo.TaskId,
		},
	}

	msgStr, err := json.Marshal(req)
	if err != nil {
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
		return
	}
	result, err := robot_service.S.SendMqttMsg(context.Background(), 12, tasks.SN, req.Content.SessionID, msgStr)

	if err != nil {
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
	} else if result == "" {
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
	}

	code, _ := jsonparser.GetInt([]byte(result), "content", "code")
	if code != 0 {
		appG.Response(http.StatusInternalServerError, e.ERROR, nil)
		return
	}

	data := make(map[string]interface{})

	task := models.RobotTaskTech{
		TaskStatus: "5",
	}
	models.UpdateTask(reqInfo.TaskId, task)
	appG.Response(http.StatusOK, e.SUCCESS, data)
}
